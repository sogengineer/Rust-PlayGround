use std::collections::BinaryHeap;
use std::cmp::Reverse;
use std::{u32, usize};

// =============================================================================
// ğŸ“š ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³• ç·´ç¿’å•é¡Œé›†
// =============================================================================

type Graph = Vec<Vec<(usize, u32)>>;

// =============================================================================
// ç·´ç¿’å•é¡Œ1: åŸºæœ¬çš„ãªãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã®å®Ÿè£…
// =============================================================================
// 
// ä»¥ä¸‹ã®éƒ½å¸‚é–“ã®ç§»å‹•ã‚³ã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚Œã¦ã„ã¾ã™ï¼š
// æ±äº¬(0) --30-- æ¨ªæµœ(1)
//   |              |
//  50             20
//   |              |
// å¤§é˜ª(2) --40-- äº¬éƒ½(3)
//   |              |
//  60             15
//   |              |
// åå¤å±‹(4)------ç¥æˆ¸(5)
//        25
//
// TODO: æ±äº¬ã‹ã‚‰å…¨éƒ½å¸‚ã¸ã®æœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã‚‹
//     let graph1: Graph = vec![
//     vec![(1, 30), (2, 50)],           // æ±äº¬: æ¨ªæµœ(30), å¤§é˜ª(50)
//     vec![(0, 30), (3, 20)],           // æ¨ªæµœ: æ±äº¬(30), äº¬éƒ½(20)
//     vec![(0, 50), (3, 40), (4, 60)],  // å¤§é˜ª: æ±äº¬(50), äº¬éƒ½(40), åå¤å±‹(60)
//     vec![(1, 20), (2, 40), (5, 15)],  // äº¬éƒ½: æ¨ªæµœ(20), å¤§é˜ª(40), ç¥æˆ¸(15)
//     vec![(2, 60), (5, 25)],           // åå¤å±‹: å¤§é˜ª(60), ç¥æˆ¸(25)
//     vec![(3, 15), (4, 25)],           // ç¥æˆ¸: äº¬éƒ½(15), åå¤å±‹(25)
// ];
fn practice1_simple_dijkstra(graph: &Graph, start: usize) -> Vec<u32> {
    // TODO: ã“ã“ã«å®Ÿè£…ã‚’æ›¸ã
    // ãƒ’ãƒ³ãƒˆ:
    // 1. distancesé…åˆ—ã‚’ç„¡é™å¤§ã§åˆæœŸåŒ–
    // 2. heapï¼ˆå„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ï¼‰ã‚’ä½œæˆ
    // 3. å§‹ç‚¹ã®è·é›¢ã‚’0ã«è¨­å®š
    // 4. whileæ–‡ã§ãƒ’ãƒ¼ãƒ—ã‹ã‚‰å–ã‚Šå‡ºã—ã¦å‡¦ç†
    let n = graph.len();
    let mut distances = vec!(u32::MAX; n);
    let mut heap = BinaryHeap::new();
    
    distances[start] = 0;
    heap.push(Reverse((0, start)));
    while let Some(Reverse((cost, node))) = heap.pop() {
        if cost > distances[node] {
            continue;
        }
        for &(next_node, edge_cost) in &graph[node] {
            let new_cost = edge_cost + cost;
            if new_cost < distances[next_node] {
                distances[next_node] = new_cost;
                heap.push(Reverse((new_cost, next_node)));
            }
        }
    };
    return distances

}

// =============================================================================
// ç·´ç¿’å•é¡Œ2: ç‰¹å®šã®2ç‚¹é–“ã®æœ€çŸ­è·é›¢
// =============================================================================
//
// å§‹ç‚¹ã‹ã‚‰çµ‚ç‚¹ã¸ã®æœ€çŸ­è·é›¢ã ã‘ã‚’æ±‚ã‚ã‚‹é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚
// çµ‚ç‚¹ã«åˆ°é”ã—ãŸã‚‰å‡¦ç†ã‚’æ‰“ã¡åˆ‡ã‚‹ã“ã¨ã§åŠ¹ç‡åŒ–ã§ãã¾ã™ã€‚

fn practice2_shortest_distance(graph: &Graph, start: usize, end: usize) -> Option<u32> {
    // TODO: ã“ã“ã«å®Ÿè£…ã‚’æ›¸ã
    // ãƒ’ãƒ³ãƒˆ:
    // 1. åŸºæœ¬çš„ãªãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã¨åŒã˜
    // 2. ãŸã ã—ã€endãƒãƒ¼ãƒ‰ã‚’å‡¦ç†ã—ãŸã‚‰å³åº§ã«return
    // 3. åˆ°é”ã§ããªã„å ´åˆã¯None
    let n = graph.len();
    let mut distances = vec!(u32::MAX; n);
    let mut heap = BinaryHeap::new();

    distances[start] = 0;
    heap.push(Reverse((0, start)));
    while let Some(Reverse((cost ,node))) = heap.pop() {
        if cost > distances[node] {
            continue;
        }
        if node == end {
            return Some(distances[node]);
        }
        for &(next_node, edge_cost) in &graph[node] {
            let new_cost: u32 = edge_cost + cost;
            if new_cost < distances[next_node] {
                distances[next_node] = new_cost;
                heap.push(Reverse((new_cost, next_node)));
            }
        }
    };
    None
}

// =============================================================================
// ç·´ç¿’å•é¡Œ3: çµŒè·¯ã®æœ¬æ•°ã‚’æ•°ãˆã‚‹
// =============================================================================
//
// å§‹ç‚¹ã‹ã‚‰çµ‚ç‚¹ã¸ã®ã€Œæœ€çŸ­çµŒè·¯ã€ãŒä½•é€šã‚Šã‚ã‚‹ã‹æ•°ãˆã‚‹é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚
// ä¾‹ï¼šAâ†’Bâ†’D ã¨ Aâ†’Câ†’D ãŒåŒã˜ã‚³ã‚¹ãƒˆãªã‚‰ã€2é€šã‚Š

fn practice3_count_shortest_paths(graph: &Graph, start: usize, end: usize) -> usize {
    let n = graph.len();
    let mut distances = vec![u32::MAX; n];
    let mut path_count = vec![0; n];  // â† Vec::new()ã‹ã‚‰å¤‰æ›´
    let mut heap: BinaryHeap<Reverse<(u32, usize)>> = BinaryHeap::new();

    distances[start] = 0;
    path_count[start] = 1;  // â† è¿½åŠ ï¼šå§‹ç‚¹ã¸ã®çµŒè·¯ã¯1é€šã‚Š
    heap.push(Reverse((0, start)));

    while let Some(Reverse((cost, node))) = heap.pop() {
        if cost > distances[node] {
            continue;
        }

        for &(next_node, edge_cost) in &graph[node] {
            let new_cost = cost + edge_cost;

            if new_cost < distances[next_node] {
                distances[next_node] = new_cost;
                path_count[next_node] = path_count[node];  // â† è¿½åŠ ï¼šçµŒè·¯æ•°ã‚’ã‚³ãƒ”ãƒ¼
                heap.push(Reverse((new_cost, next_node)));
            } else if new_cost == distances[next_node] {  // â† è¿½åŠ ï¼šåŒã˜ã‚³ã‚¹ãƒˆã®å ´åˆ
                path_count[next_node] += path_count[node];  // çµŒè·¯æ•°ã‚’åŠ ç®—
            }
        }
    }

    return path_count[end]  // â† path_count.len()ã‹ã‚‰å¤‰æ›´
}

// =============================================================================
// ç·´ç¿’å•é¡Œ4: åˆ¶ç´„ä»˜ãæœ€çŸ­çµŒè·¯
// =============================================================================
//
// ã€Œé€šéã§ãã‚‹ãƒãƒ¼ãƒ‰æ•°ãŒæœ€å¤§Kå€‹ã€ã¨ã„ã†åˆ¶ç´„ä»˜ãã§æœ€çŸ­çµŒè·¯ã‚’æ±‚ã‚ã¦ãã ã•ã„ã€‚
// ä¾‹ï¼šK=3ãªã‚‰ã€å§‹ç‚¹â†’ä¸­ç¶™1â†’ä¸­ç¶™2â†’çµ‚ç‚¹ï¼ˆ4ãƒãƒ¼ãƒ‰ï¼‰ã¯NG

fn practice4_limited_hops(graph: &Graph, start: usize, end: usize, max_hops: usize) -> Option<u32> {
    // ã‚°ãƒ©ãƒ•ã®ãƒãƒ¼ãƒ‰æ•°ã‚’å–å¾—ï¼ˆä¾‹ï¼š6å€‹ã®éƒ½å¸‚ï¼‰
    let n = graph.len();
    
    // 2æ¬¡å…ƒé…åˆ—ã‚’ä½œæˆ: distances[ãƒãƒ¼ãƒ‰ç•ªå·][ãƒ›ãƒƒãƒ—æ•°] = ãã®ãƒãƒ¼ãƒ‰ã«ãã®ãƒ›ãƒƒãƒ—æ•°ã§åˆ°é”ã™ã‚‹æœ€å°ã‚³ã‚¹ãƒˆ
    // max_hops=2ãªã‚‰ã€[0ãƒ›ãƒƒãƒ—, 1ãƒ›ãƒƒãƒ—, 2ãƒ›ãƒƒãƒ—]ã®3ã¤åˆ†ã®é ˜åŸŸãŒå¿…è¦ãªã®ã§ max_hops+1
    // ä¾‹: distances[3][1] = ãƒãƒ¼ãƒ‰3ã«1ãƒ›ãƒƒãƒ—ã§åˆ°é”ã™ã‚‹æœ€å°ã‚³ã‚¹ãƒˆ
    let mut distances = vec![vec![u32::MAX; max_hops + 1]; n];
    
    // å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼: (ã‚³ã‚¹ãƒˆ, ãƒãƒ¼ãƒ‰ç•ªå·, ãƒ›ãƒƒãƒ—æ•°) ã®ã‚¿ãƒ—ãƒ«ã‚’æ ¼ç´
    // Reverseã§åŒ…ã‚€ã“ã¨ã§ã€ã‚³ã‚¹ãƒˆãŒå°ã•ã„é †ã«å–ã‚Šå‡ºã›ã‚‹
    let mut heap: BinaryHeap<Reverse<(u32, usize, usize)>> = BinaryHeap::new();

    // å§‹ç‚¹ã¸ã®0ãƒ›ãƒƒãƒ—ã§ã®ã‚³ã‚¹ãƒˆã¯0ï¼ˆç§»å‹•ãªã—ã€è‡ªåˆ†è‡ªèº«ï¼‰
    // ä¾‹: start=0ãªã‚‰ã€distances[0][0] = 0
    distances[start][0] = 0;
    
    // ãƒ’ãƒ¼ãƒ—ã«å§‹ç‚¹ã‚’è¿½åŠ : (ã‚³ã‚¹ãƒˆ0, å§‹ç‚¹ãƒãƒ¼ãƒ‰, 0ãƒ›ãƒƒãƒ—)
    // ä¾‹: Reverse((0, 0, 0)) â†’ æ±äº¬ã‹ã‚‰0ãƒ›ãƒƒãƒ—ã§æ±äº¬ã«åˆ°é”
    heap.push(Reverse((0, start, 0)));
    
    // ãƒ’ãƒ¼ãƒ—ãŒç©ºã«ãªã‚‹ã¾ã§å‡¦ç†ã‚’ç¹°ã‚Šè¿”ã™
    while let Some(Reverse((cost, node, hop_count))) = heap.pop() {
        // ãƒ›ãƒƒãƒ—æ•°ãŒåˆ¶é™ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        // ä¾‹: max_hops=2ã§hop_count=3ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ3ãƒ›ãƒƒãƒ—ã¯è¨±å¯ã•ã‚Œãªã„ï¼‰
        if hop_count > max_hops {
            continue;
        }
        
        // æ—¢ã«ã‚ˆã‚Šè‰¯ã„çµŒè·¯ãŒè¦‹ã¤ã‹ã£ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        // ä¾‹: distances[3][1]=50 ã§ cost=60 ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ—¢ã«è‰¯ã„çµŒè·¯ãŒã‚ã‚‹ï¼‰
        if cost > distances[node][hop_count] {
            continue;
        }
        
        // çµ‚ç‚¹ã«åˆ°é”ã—ãŸã‚‰ã€ãã®ã‚³ã‚¹ãƒˆã‚’è¿”ã™
        // ä¾‹: node=5(ç¥æˆ¸)ã§end=5ãªã‚‰ã€ç¾åœ¨ã®ã‚³ã‚¹ãƒˆã‚’è¿”ã™
        if node == end {
            return Some(cost)
        }
        
        // ã¾ã ãƒ›ãƒƒãƒ—æ•°ã«ä½™è£•ãŒã‚ã‚‹å ´åˆã®ã¿ã€éš£æ¥ãƒãƒ¼ãƒ‰ã‚’æ¢ç´¢
        // ä¾‹: hop_count=1, max_hops=2 ãªã‚‰ã€ã‚ã¨1ãƒ›ãƒƒãƒ—ã§ãã‚‹
        if hop_count < max_hops {
            // ç¾åœ¨ã®ãƒãƒ¼ãƒ‰ã‹ã‚‰è¡Œã‘ã‚‹å…¨ã¦ã®éš£æ¥ãƒãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
            // ä¾‹: node=0(æ±äº¬)ãªã‚‰ã€æ¨ªæµœã¨å¤§é˜ªã‚’ãƒã‚§ãƒƒã‚¯
            for &(next_node, edge_cost) in &graph[node] {
                // æ–°ã—ã„ã‚³ã‚¹ãƒˆ = ç¾åœ¨ã¾ã§ã®ã‚³ã‚¹ãƒˆ + ã‚¨ãƒƒã‚¸ã®ã‚³ã‚¹ãƒˆ
                // ä¾‹: cost=30(æ±äº¬â†’æ¨ªæµœ) + edge_cost=20(æ¨ªæµœâ†’äº¬éƒ½) = 50
                let new_cost = cost + edge_cost;
                
                // æ¬¡ã®ãƒ›ãƒƒãƒ—æ•° = ç¾åœ¨ã®ãƒ›ãƒƒãƒ—æ•° + 1
                // ä¾‹: hop_count=1 â†’ next_hop=2ï¼ˆ2ãƒ›ãƒƒãƒ—ç›®ï¼‰
                let next_hop = hop_count + 1;
                
                // ã‚ˆã‚Šè‰¯ã„çµŒè·¯ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã®ã¿æ›´æ–°
                // ä¾‹: distances[3][2]=100 ã§ new_cost=50 ãªã‚‰æ›´æ–°
                if new_cost < distances[next_node][next_hop] {
                    // æœ€çŸ­è·é›¢ã‚’æ›´æ–°
                    distances[next_node][next_hop] = new_cost;
                    
                    // ãƒ’ãƒ¼ãƒ—ã«æ–°ã—ã„çŠ¶æ…‹ã‚’è¿½åŠ 
                    // ä¾‹: Reverse((50, 3, 2)) â†’ ã‚³ã‚¹ãƒˆ50ã§äº¬éƒ½ã«2ãƒ›ãƒƒãƒ—ã§åˆ°é”
                    heap.push(Reverse((new_cost, next_node, next_hop)));
                }
            } 
        }
    }
    
    // ãƒ’ãƒ¼ãƒ—ãŒç©ºã«ãªã£ã¦ã‚‚çµ‚ç‚¹ã«åˆ°é”ã§ããªã‹ã£ãŸå ´åˆã¯None
    None
}

// =============================================================================
// ç·´ç¿’å•é¡Œ5: è² ã®é‡ã¿ã‚’æ¤œå‡º
// =============================================================================
//
// ã‚°ãƒ©ãƒ•ã«è² ã®é‡ã¿ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚
// ï¼ˆãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã¯è² ã®é‡ã¿ã§ã¯æ­£ã—ãå‹•ä½œã—ã¾ã›ã‚“ï¼‰

fn practice5_has_negative_edge(_edges: &[(usize, usize, i32)]) -> bool {
    // TODO: ã“ã“ã«å®Ÿè£…ã‚’æ›¸ã
    // edges: [(from, to, weight), ...]
    
    false
}

// =============================================================================
// ãƒ†ã‚¹ãƒˆç”¨ã®mainé–¢æ•°
// =============================================================================

fn main() {
    println!("=== ğŸ“š ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³• ç·´ç¿’å•é¡Œ ===\n");
    
    // ç·´ç¿’å•é¡Œ1ç”¨ã®ã‚°ãƒ©ãƒ•
    let graph1: Graph = vec![
        vec![(1, 30), (2, 50)],           // æ±äº¬: æ¨ªæµœ(30), å¤§é˜ª(50)
        vec![(0, 30), (3, 20)],           // æ¨ªæµœ: æ±äº¬(30), äº¬éƒ½(20)
        vec![(0, 50), (3, 40), (4, 60)],  // å¤§é˜ª: æ±äº¬(50), äº¬éƒ½(40), åå¤å±‹(60)
        vec![(1, 20), (2, 40), (5, 15)],  // äº¬éƒ½: æ¨ªæµœ(20), å¤§é˜ª(40), ç¥æˆ¸(15)
        vec![(2, 60), (5, 25)],           // åå¤å±‹: å¤§é˜ª(60), ç¥æˆ¸(25)
        vec![(3, 15), (4, 25)],           // ç¥æˆ¸: äº¬éƒ½(15), åå¤å±‹(25)
    ];
    
    println!("éƒ½å¸‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯:");
    println!("æ±äº¬(0) --30-- æ¨ªæµœ(1)");
    println!("  |              |");
    println!(" 50             20");
    println!("  |              |");
    println!("å¤§é˜ª(2) --40-- äº¬éƒ½(3)");
    println!("  |              |");
    println!(" 60             15");
    println!("  |              |");
    println!("åå¤å±‹(4)------ç¥æˆ¸(5)");
    println!("       25");
    println!();
    
    // ç·´ç¿’å•é¡Œ1ã®ãƒ†ã‚¹ãƒˆ
    println!("=== ç·´ç¿’å•é¡Œ1: åŸºæœ¬çš„ãªãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³• ===");
    let distances = practice1_simple_dijkstra(&graph1, 0);
    if distances.is_empty() {
        println!("æœªå®Ÿè£…ã§ã™");
    } else {
        let cities = ["æ±äº¬", "æ¨ªæµœ", "äº¬éƒ½", "å¤§é˜ª", "åå¤å±‹", "ç¥æˆ¸"];
        for (i, &dist) in distances.iter().enumerate() {
            if i < cities.len() {
                println!("æ±äº¬ â†’ {}: {}", cities[i], 
                    if dist == u32::MAX { "åˆ°é”ä¸å¯".to_string() } else { format!("{}km", dist) });
            }
        }
    }
    println!("æœŸå¾…å€¤: æ±äº¬â†’æ±äº¬:0, æ¨ªæµœ:30, äº¬éƒ½:50, å¤§é˜ª:50, åå¤å±‹:90, ç¥æˆ¸:65");
    println!();
    
    // ç·´ç¿’å•é¡Œ2ã®ãƒ†ã‚¹ãƒˆ
    println!("=== ç·´ç¿’å•é¡Œ2: ç‰¹å®šã®2ç‚¹é–“ã®æœ€çŸ­è·é›¢ ===");
    match practice2_shortest_distance(&graph1, 0, 5) {
        Some(dist) => println!("æ±äº¬ â†’ ç¥æˆ¸: {}km", dist),
        None => println!("æœªå®Ÿè£…ã¾ãŸã¯åˆ°é”ä¸å¯"),
    }
    println!("æœŸå¾…å€¤: 65km (æ±äº¬â†’æ¨ªæµœâ†’äº¬éƒ½â†’ç¥æˆ¸)");
    println!();
    
    // ç·´ç¿’å•é¡Œ3ã®ãƒ†ã‚¹ãƒˆ
    println!("=== ç·´ç¿’å•é¡Œ3: æœ€çŸ­çµŒè·¯ã®æœ¬æ•° ===");
    let simple_graph: Graph = vec![
        vec![(1, 10), (2, 10)],  // A: B(10), C(10)
        vec![(3, 10)],           // B: D(10)
        vec![(3, 10)],           // C: D(10)
        vec![],                  // D: ãªã—
    ];
    let count = practice3_count_shortest_paths(&simple_graph, 0, 3);
    println!("A â†’ Dã®æœ€çŸ­çµŒè·¯ã®æœ¬æ•°: {}", count);
    println!("æœŸå¾…å€¤: 2é€šã‚Š (Aâ†’Bâ†’Dã¨Aâ†’Câ†’D)");
    println!();
    
    // ç·´ç¿’å•é¡Œ4ã®ãƒ†ã‚¹ãƒˆ
    println!("=== ç·´ç¿’å•é¡Œ4: åˆ¶ç´„ä»˜ãæœ€çŸ­çµŒè·¯ ===");
    match practice4_limited_hops(&graph1, 0, 5, 2) {
        Some(dist) => println!("æ±äº¬ â†’ ç¥æˆ¸ (æœ€å¤§2ãƒ›ãƒƒãƒ—): {}km", dist),
        None => println!("æœªå®Ÿè£…ã¾ãŸã¯æ¡ä»¶ã‚’æº€ãŸã™çµŒè·¯ãªã—"),
    }
    println!("æœŸå¾…å€¤: æ¡ä»¶ã‚’æº€ãŸã™çµŒè·¯ãªã—ï¼ˆæœ€çŸ­ã§ã‚‚3ãƒ›ãƒƒãƒ—å¿…è¦ï¼‰");
    println!();
    
    // ç·´ç¿’å•é¡Œ5ã®ãƒ†ã‚¹ãƒˆ
    println!("=== ç·´ç¿’å•é¡Œ5: è² ã®é‡ã¿æ¤œå‡º ===");
    let edges_positive = vec![(0, 1, 10), (1, 2, 20), (2, 3, 30)];
    let edges_negative = vec![(0, 1, 10), (1, 2, -5), (2, 3, 30)];
    
    println!("æ­£ã®é‡ã¿ã®ã¿: {}", 
        if practice5_has_negative_edge(&edges_positive) { "è² ã‚ã‚Š" } else { "è² ãªã—" });
    println!("è² ã®é‡ã¿ã‚ã‚Š: {}", 
        if practice5_has_negative_edge(&edges_negative) { "è² ã‚ã‚Š" } else { "è² ãªã—" });
    println!();
    
    println!("ãƒ’ãƒ³ãƒˆ:");
    println!("- ç·´ç¿’å•é¡Œ1: åŸºæœ¬ã®ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’ãã®ã¾ã¾å®Ÿè£…");
    println!("- ç·´ç¿’å•é¡Œ2: endã«åˆ°é”ã—ãŸã‚‰æ—©æœŸreturn");
    println!("- ç·´ç¿’å•é¡Œ3: åŒã˜ã‚³ã‚¹ãƒˆã®çµŒè·¯ã‚’æ•°ãˆã‚‹");
    println!("- ç·´ç¿’å•é¡Œ4: ãƒ›ãƒƒãƒ—æ•°ã‚‚çŠ¶æ…‹ã¨ã—ã¦ç®¡ç†");
    println!("- ç·´ç¿’å•é¡Œ5: å˜ç´”ã«weight < 0ã‚’ãƒã‚§ãƒƒã‚¯");
}
# 制約付きダイクストラ法のフローチャート

## アルゴリズムの流れ

```
開始: practice4_limited_hops(graph, start, end, max_hops)
    ↓
┌─────────────────────────────────────┐
│ 初期化                              │
│ - n = graph.len()                   │
│ - distances[n][max_hops+1] = ∞で初期化│
│ - distances[start][0] = 0           │
│ - heap.push((0, start, 0))          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ while heap が空でない               │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ (cost, node, hop_count) = heap.pop()│
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ hop_count > max_hops?               │
├─── Yes → continue（次のループへ）    │
└─── No → 次へ                        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ cost > distances[node][hop_count]?  │
├─── Yes → continue（既に良い経路あり） │
└─── No → 次へ                        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ node == end?                        │
├─── Yes → return Some(cost) 🎯       │
└─── No → 次へ                        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ hop_count < max_hops?               │
├─── No → continue（ホップ数限界）     │
└─── Yes → 隣接ノード探索              │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ for (next_node, edge_cost) in 隣接  │
│   - new_cost = cost + edge_cost     │
│   - next_hop = hop_count + 1        │
│                                      │
│   if new_cost < distances[next][hop]│
│     - distances更新                  │
│     - heap.push(new_cost,next,hop)  │
└─────────────────────────────────────┘
    ↓
  ループ継続
    ↓
全て処理後: return None（到達不可）
```

## 具体例：東京→神戸（max_hops=2）

### グラフ構造
```
東京(0) --30-- 横浜(1)
  |              |
 50             20
  |              |
大阪(2) --40-- 京都(3)
  |              |
 60             15
  |              |
名古屋(4)------神戸(5)
       25
```

### 実行トレース

| ステップ | heap.pop() | 処理内容 | heap追加 |
|---------|------------|----------|----------|
| 初期 | - | distances[0][0]=0 | (0,東京,0) |
| 1 | (0,東京,0) | 東京!=神戸, hop=0<2 | (30,横浜,1), (50,大阪,1) |
| 2 | (30,横浜,1) | 横浜!=神戸, hop=1<2 | (50,京都,2) |
| 3 | (50,大阪,1) | 大阪!=神戸, hop=1<2 | (110,名古屋,2) |
| 4 | (50,京都,2) | 京都!=神戸, hop=2=2 | 探索不可（限界） |
| 5 | (110,名古屋,2) | 名古屋!=神戸, hop=2=2 | 探索不可（限界） |
| 終了 | - | heap空 | **None返す** |

### distances配列の状態

```
distances[ノード][ホップ数] = コスト

        [0hop] [1hop] [2hop]
東京[0]    0      ∞      ∞
横浜[1]    ∞     30      ∞
大阪[2]    ∞     50      ∞
京都[3]    ∞      ∞     50
名古屋[4]  ∞      ∞    110
神戸[5]    ∞      ∞      ∞  ← 到達不可
```

## 重要なポイント

### 1. なぜ2次元配列なのか
- **同じノードでも、ホップ数が違えば別の状態**
- 例：京都への経路
  - 1ホップ：不可能（直接行けない）
  - 2ホップ：50（東京→横浜→京都）
  - 3ホップ：90（東京→大阪→京都）※別経路

### 2. ホップ数の数え方
```
東京 → 横浜 → 京都 → 神戸
 0     1      2      3   ← ホップ数
       ↑      ↑      ↑
     1移動  2移動  3移動
```

### 3. 早期終了の条件
- `node == end`で即座に`return Some(cost)`
- これが最短距離（ヒープは最小コスト順）

### 4. 制約チェックのタイミング
- `hop_count > max_hops`：処理をスキップ
- `hop_count < max_hops`：まだ探索可能
- `hop_count == max_hops`：これ以上進めない

## まとめ

制約付きダイクストラ法は、通常のダイクストラ法に「ホップ数」という状態を追加したもの。2次元配列で`[ノード][ホップ数]`の組み合わせごとに最小コストを管理することで、ホップ数制限下での最短経路を求められる。